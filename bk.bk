  
class FBAttachable a where 
  attachToFramebuffer :: forall eff. a -> GLenum -> ContextR eff Unit

instance loadedRenderbufferFBAttachable ::  FBAttachable LoadedRenderbuffer where
  attachToFramebuffer (LoadedRenderbuffer rb) target = 
    framebufferRenderbuffer gl_FRAMEBUFFER target gl_RENDERBUFFER rb.renderbuffer

instance loadedTextureFBAttachable :: FBAttachable LoadedTexture where
  attachToFramebuffer(LoadedTexture t) target = 
    framebufferTexture2D gl_FRAMEBUFFER target (getValue t.textureTarget) t.texture 0 
    
---- PROGRAM

getShaderParameter' :: forall eff. WebGLShader -> ShaderParamQuery -> ContextR eff (Either String ShaderParamResponse)
getShaderParameter' s q = do
  case q of
    DeleteStatusQuery -> do
      res <- runExcept <<< readBoolean <$>  getShaderParameter s (getValue q)
      case res of
          Left _ -> pure $ Left "Error reading 'getShaderParameter' response"
          Right v -> pure $ Right $ DeleteStatus v
    CompileStatusQuery -> do
      res <- runExcept <<< readBoolean <$>  getShaderParameter s (getValue q)
      case res of
          Left _ -> pure $ Left "Error reading 'getShaderParameter' response"
          Right v -> pure $ Right $ CompileStatus v
    TypeOfShaderQuery -> do
      res <- runExcept <<< readInt <$>  getShaderParameter s (getValue q)
      case res of
          Left _ -> pure $ Left "Error reading 'getShaderParameter' response"
          Right v -> pure $ Right $ TypeOfShader v

getProgramParameter' :: forall eff. WebGLProgram -> ProgramParamQuery -> ContextR eff (Either String ProgramParamResponse)
getProgramParameter' p q = do
  res <- getProgramParameter p (getValue q)
  case q of 
    ProgramDeleteStatusQuery -> 
      case runExcept <<< readBoolean $ res of
        Left _ -> pure $ Left $ "Error reading 'getProgramParameter' response"
        Right v -> pure $ Right $ ProgramDeleteStatus v
    LinkStatusQuery -> 
      case runExcept <<< readBoolean $ res of
        Left _ -> pure $ Left $ "Error reading 'getProgramParameter' response"
        Right v -> pure $ Right $ LinkStatus v

buildShader :: forall eff. String -> ShaderType -> ContextR eff (Either String WebGLShader)
buildShader src t = do
  shader <- createShader (getValue t)
  shaderSource shader src
  compileShader shader
  p <- getShaderParameter' shader CompileStatusQuery
  case p of
    Right status -> 
      case status of 
        (CompileStatus true) -> pure $ Right shader
        (CompileStatus false) -> Left <$> getShaderInfoLog shader
        otherwise -> pure $ Left "Should not happen"
    Left e -> pure $ Left e

buildProgram :: forall eff. String -> String -> ContextR eff (Either String WebGLProgram)
buildProgram vs fs = do
  vertexShaderE <- buildShader vs VertexShader
  case vertexShaderE of
    Left e -> pure $ Left e
    Right vertexShader -> do
      fragmentShaderE <- buildShader fs FragmentShader
      case fragmentShaderE of
        Left e -> pure $ Left e
        Right fragmentShader -> do
          program <- createProgram
          attachShader program vertexShader
          attachShader program fragmentShader
          linkProgram program
          statusE <- getProgramParameter' program LinkStatusQuery
          case statusE of
            Right status -> 
              case status of
                (LinkStatus true) -> pure $ Right program
                (LinkStatus false) -> Left <$> getProgramInfoLog program
                otherwise -> pure $ Left "Should not happen"
            Left e -> pure $ Left e


getProgramUniformLocation :: forall eff. WebGLProgram -> Uniform -> ContextR eff (Either String WebGLUniformLocation)
getProgramUniformLocation p u = do
  locationM <- getUniformLocation p (uniformName u)
  case locationM of
    Nothing -> pure $ Left $ "Uniform '" <> (uniformName u) <> "not found."
    Just loc -> pure $ Right loc

getProgramUniformLocationsMap :: forall eff. WebGLProgram -> Array Uniform -> ContextR eff (Either String (StrMap WebGLUniformLocation))
getProgramUniformLocationsMap p us = do
  locsE <- getProgramUniformLocations p us
  case locsE of 
    Left e -> pure $ Left e
    Right locs -> pure $ Right $ fromFoldable $ zip (uniformName <$> us) locs

getProgramUniformLocations :: forall eff.  WebGLProgram -> Array Uniform -> ContextR eff (Either String  (Array WebGLUniformLocation))
getProgramUniformLocations p us = do
  sequence <$> traverse (\u -> (eitherFromMaybe $ "Could not find uniform '" <> (uniformName u) <> "' in the program.") <$> (getUniformLocation p (uniformName u))) us


getProgramAttribLocation :: forall eff. WebGLProgram -> String -> ContextR eff (Either String GLint)
getProgramAttribLocation p a = do
  location <- getAttribLocation p a
  case location >= 0 of
    true -> pure $ Right location
    false -> pure $ Left $ "Counld not fint attribute '" <> a <> "' in the shader program."

getProgramAttribLocations :: forall eff. WebGLProgram -> (Array String) -> ContextR eff (Either String (Array GLint))
getProgramAttribLocations p as = do
  sequence <$> traverse (\a -> getProgramAttribLocation p a) as

getProgramAttribLocationsMap :: forall eff. WebGLProgram -> (Array String) -> ContextR eff (Either String (StrMap GLint))
getProgramAttribLocationsMap p as = do
  locsE <- getProgramAttribLocations p as
  case locsE of
    Left e -> pure $ Left e
    Right locs -> pure $ Right $ fromFoldable $ zip as locs